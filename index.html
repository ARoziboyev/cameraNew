<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Zoom + Blink Snapshot + HUD</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #000;
    }
    canvas, video {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      transform-origin: center center;
    }
    #hud {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 200px;
      height: 200px;
      border: 3px solid #fff;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      color: #fff;
      font-family: monospace;
      z-index: 1000;
      pointer-events: none;
      text-align: center;
    }
  </style>
</head>
<body>
  <video id="video" autoplay muted playsinline style="display: none;"></video>
  <canvas id="output"></canvas>
  <div id="hud">1.0x<br>0°</div>

  <!-- Mediapipe -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.min.js"></script>

  <script>
    const videoElement = document.getElementById('video');
    const canvasElement = document.getElementById('output');
    const canvasCtx = canvasElement.getContext('2d');
    const hud = document.getElementById('hud');

    let currentZoom = 1.0;
    let angle = 0;

    const hands = new Hands({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
    });

    hands.setOptions({
      maxNumHands: 2,
      modelComplexity: 1,
      minDetectionConfidence: 0.7,
      minTrackingConfidence: 0.7
    });

    const faceMesh = new FaceMesh({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
    });

    faceMesh.setOptions({
      maxNumFaces: 1,
      refineLandmarks: true,
      minDetectionConfidence: 0.7,
      minTrackingConfidence: 0.7
    });

    let lastBlinkTime = 0;

    function getEAR(landmarks, topIdx, bottomIdx, leftIdx, rightIdx) {
      const top = landmarks[topIdx];
      const bottom = landmarks[bottomIdx];
      const left = landmarks[leftIdx];
      const right = landmarks[rightIdx];

      const vertical = Math.hypot(top.x - bottom.x, top.y - bottom.y);
      const horizontal = Math.hypot(left.x - right.x, left.y - right.y);
      return vertical / horizontal;
    }

    function saveSnapshot() {
      const link = document.createElement('a');
      link.download = `snapshot_${Date.now()}.png`;
      link.href = canvasElement.toDataURL('image/png');
      link.click();
    }

    function processFaceMesh(results) {
      if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
        const landmarks = results.multiFaceLandmarks[0];

        const leftEAR = getEAR(landmarks, 386, 374, 263, 362);
        const rightEAR = getEAR(landmarks, 159, 145, 133, 33);

        const avgEAR = (leftEAR + rightEAR) / 2;

        const now = Date.now();
        if (avgEAR < 0.20 && now - lastBlinkTime > 2000) {
          lastBlinkTime = now;
          saveSnapshot();
        }
      }
    }

    hands.onResults(processHands);
    faceMesh.onResults(processFaceMesh);

    const camera = new Camera(videoElement, {
      onFrame: async () => {
        await faceMesh.send({ image: videoElement });
        await hands.send({ image: videoElement });
      },
      width: 600000000,
      height: 600000000
    });
    camera.start();

    function getDistance(p1, p2) {
      const dx = p1.x - p2.x;
      const dy = p1.y - p2.y;
      return Math.sqrt(dx * dx + dy * dy);
    }

    function processHands(results) {
      canvasElement.width = videoElement.videoWidth;
      canvasElement.height = videoElement.videoHeight;

      canvasCtx.save();
      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
      canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

      if (results.multiHandLandmarks.length === 2) {
        const hand1 = results.multiHandLandmarks[0];
        const hand2 = results.multiHandLandmarks[1];

        const p1 = hand1[0];
        const p2 = hand2[0];

        const dx = (p1.x - p2.x) * canvasElement.width;
        const dy = (p1.y - p2.y) * canvasElement.height;
        const distance = Math.sqrt(dx * dx + dy * dy);

        let zoom = distance / 150;
        zoom = Math.max(1, Math.min(zoom, 3));
        currentZoom = zoom;

        canvasElement.style.transform = `scale(${zoom})`;
      } else {
        currentZoom = 1.0;
        canvasElement.style.transform = `scale(1)`;
      }

      for (const landmarks of results.multiHandLandmarks) {
        drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, { color: '#fff', lineWidth: 2 });
        drawLandmarks(canvasCtx, landmarks, { color: '#fff', lineWidth: 1 });
      }

      canvasCtx.restore();
    }

    function updateHUD() {
      angle = (angle + 2) % 360;
      hud.innerHTML = `${currentZoom.toFixed(1)}x<br>${angle}°`;
      requestAnimationFrame(updateHUD);
    }

    updateHUD();
  </script>
</body>
</html>
